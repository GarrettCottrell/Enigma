###**Functionality**

 3: Enigma Class with encrypt and decrypt methods successfully implemented. Encrypt/decrypt command line interfaces successfully implemented
    --My program does the things

###**Object Oriented Programming**

 4: Students have implemented either inheritance or at least one module in a logical manner.
    Students can speak as to how/why inheritance and modules made sense for the given implementations, why they improve the organization of the code, and the distinction between the two.

    --I used a module to contain specifically all the code for creating my shifts, which is then used by both my decipher and cipher classes and lets my program adhere better by the DRY principle (don't repeat yourself), so rather than using that code in two places, I can just have it once and use it in both places.

    --Also, my two classes did have slightly different ways of using these methods and had different instance variables, so I thought using a module here would be better than just simply using inheritance

###**Ruby Conventions and Mechanics**

2.5/3: Code is mostly properly indented, spaced, and lines are not excessively long. Class, method, variable, and file names follow convention. Some enumerables/data structures chosen are the most efficient tool for a given job, and students can speak as to why those enumerables/data structures were chosen. At least one hash is implemented in a way that makes logical sense.

    --I think that I have a few methods that are too long and my formatting in general isn't great. I also think that there were a few areas where I could have used different enumerables and had shorter code as a result.


###**Test Driven Development**

Every method is tested at both the unit and integration level, and completely verify expected behavior (i.e., if a single method does 3 things, all 3 things are explicitly tested). Obvious edge cases are addressed. git history demonstrates students are writing tests before implementation code. Test coverage metrics show coverage at 99% or greater.

    --I did not use mocks or stub but all my methods are tested at the unit and integration level and test all the expected behavior. I've tested obvious edge cases and wrote almost all my tests prior to my code. I have 100% test coverage.


###**Version Control**

3.2: At least 30 commits. Most pull requests include related and logical chunks of functionality, and are named and documented to clearly communicate the purpose of the pull request. No more than 3 commits include multiple pieces of functionality.

    --I have over 50 commits and most my pull requests are in logical pieces that are named appropriately. There are a few commits that include multiple pieces of functionality.
